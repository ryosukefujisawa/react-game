{"ast":null,"code":"// export const gameover = false;\n\nexport const CELL_SIZE = 20;\nexport const initialSnake = [{\n  x: Math.floor(CELL_SIZE / 4),\n  y: Math.floor(CELL_SIZE / 2)\n}];\nexport const generateFoodPosition = () => {\n  // let _x: number = Math.floor(Math.random() * CELL_SIZE) + 2;\n  // let _y: number = Math.floor(Math.random() * CELL_SIZE) + 2;\n  return {\n    x: Math.floor(Math.random() * CELL_SIZE),\n    y: Math.floor(Math.random() * CELL_SIZE)\n  };\n};\nexport const moveSnake = async (direction, snake, food, intervalTime, hitCount, setSnake, setFood, setGameOver, setIntervalTime, setDirection, setHitCount, setUserScore) => {\n  let newSnake = [...snake];\n  let head = {\n    ...newSnake[0]\n  };\n  if (direction !== 'STOP') {\n    setIntervalTime(prevInterval => prevInterval - 0.3);\n    setUserScore(prevScore => prevScore + 1);\n  }\n  switch (direction) {\n    case 'UP':\n      head.y -= 1;\n      break;\n    case 'DOWN':\n      head.y += 1;\n      break;\n    case 'LEFT':\n      head.x -= 1;\n      break;\n    case 'RIGHT':\n      head.x += 1;\n      break;\n    case 'STOP':\n      head.x = head.x;\n      head.y = head.y;\n      break;\n    default:\n      break;\n  }\n  if (head.x < 0 || head.y < 0 || head.x >= CELL_SIZE || head.y >= CELL_SIZE || newSnake.slice(1).some(body => body.x === head.x && body.y === head.y)) {\n    setDirection('STOP');\n    setSnake(initialSnake);\n    setIntervalTime(200);\n    // setHitCount(0);\n    // setUserScore(0);\n    setGameOver(true);\n    return;\n  }\n  if (head.x === food.x && head.y === food.y) {\n    newSnake.unshift({\n      ...head\n    });\n    setFood(generateFoodPosition());\n    setHitCount(prevCount => prevCount + 1);\n    setUserScore(prevScore => prevScore + newSnake.length * 10);\n    if (intervalTime < 40) {\n      setIntervalTime(40);\n    }\n  } else {\n    newSnake.pop();\n  }\n  newSnake.unshift(head);\n  setSnake(newSnake);\n};","map":{"version":3,"names":["CELL_SIZE","initialSnake","x","Math","floor","y","generateFoodPosition","random","moveSnake","direction","snake","food","intervalTime","hitCount","setSnake","setFood","setGameOver","setIntervalTime","setDirection","setHitCount","setUserScore","newSnake","head","prevInterval","prevScore","slice","some","body","unshift","prevCount","length","pop"],"sources":["C:/Users/藤澤 良祐/Downloads/研修/learning_fujisawa/webapp/game/src/components/SnakeGame/utils/utils.ts"],"sourcesContent":["// export const gameover = false;\r\n\r\nexport const CELL_SIZE = 20;\r\n\r\nexport interface Position {\r\n    x: number,\r\n    y: number\r\n}\r\n\r\nexport interface Score {\r\n    id: number;\r\n    name: string;\r\n    score: number;\r\n    created_at: string;\r\n    ranking: number;\r\n}\r\n\r\nexport type Direction = 'UP' | 'DOWN' | 'LEFT' | 'RIGHT' | 'STOP';\r\n\r\nexport const initialSnake: Position[] = [{x: Math.floor(CELL_SIZE/4), y: Math.floor(CELL_SIZE/2) }];\r\n\r\nexport const generateFoodPosition = (): Position => {\r\n    \r\n    // let _x: number = Math.floor(Math.random() * CELL_SIZE) + 2;\r\n    // let _y: number = Math.floor(Math.random() * CELL_SIZE) + 2;\r\n    return {\r\n        x: Math.floor(Math.random() * CELL_SIZE),\r\n        y: Math.floor(Math.random() * CELL_SIZE)\r\n    };\r\n};\r\n\r\n\r\n\r\nexport const moveSnake = async(\r\n    direction:       Direction,\r\n    snake:           Position[],\r\n    food:            Position,\r\n    intervalTime:    number,\r\n    hitCount:        number, \r\n    setSnake:        React.Dispatch<React.SetStateAction<Position[]>>,\r\n    setFood:         React.Dispatch<React.SetStateAction<Position>>,\r\n    setGameOver:     React.Dispatch<React.SetStateAction<boolean>>,\r\n    setIntervalTime: React.Dispatch<React.SetStateAction<number>>,\r\n    setDirection:    React.Dispatch<React.SetStateAction<Direction>>,\r\n    setHitCount:     React.Dispatch<React.SetStateAction<number>>,\r\n    setUserScore:    React.Dispatch<React.SetStateAction<number>>,\r\n        \r\n  ) => {\r\n    let newSnake = [...snake];\r\n    let head = { ...newSnake[0] };\r\n\r\n    if ( direction !== 'STOP' ) {\r\n        setIntervalTime(prevInterval => prevInterval - 0.3);\r\n        setUserScore(prevScore => prevScore + 1);\r\n    }\r\n    \r\n  \r\n    switch (direction) {\r\n      case 'UP':\r\n        head.y -= 1;\r\n        break;\r\n      case 'DOWN':\r\n        head.y += 1;\r\n        break;\r\n      case 'LEFT':\r\n        head.x -= 1;\r\n        break;\r\n      case 'RIGHT':\r\n        head.x += 1;\r\n        break;\r\n      case 'STOP':\r\n        head.x = head.x;\r\n        head.y = head.y;\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n\r\n    if (head.x < 0 || \r\n        head.y < 0 || \r\n        head.x >= CELL_SIZE || \r\n        head.y >= CELL_SIZE ||\r\n        newSnake.slice(1).some((body) => body.x === head.x && body.y === head.y)  \r\n    ) {\r\n        setDirection('STOP');\r\n        setSnake(initialSnake);\r\n        setIntervalTime(200);\r\n        // setHitCount(0);\r\n        // setUserScore(0);\r\n        setGameOver(true);\r\n        return ;\r\n    }\r\n\r\n    if (head.x === food.x && head.y === food.y) {\r\n        newSnake.unshift({ ...head });\r\n        setFood(generateFoodPosition());\r\n        setHitCount(prevCount => prevCount + 1);\r\n\r\n        setUserScore(prevScore => prevScore + (newSnake.length * 10));\r\n\r\n        if(intervalTime < 40 ) {\r\n          setIntervalTime(40);\r\n        }\r\n    } \r\n    else {\r\n        newSnake.pop();\r\n    }\r\n\r\n    newSnake.unshift(head);\r\n    setSnake(newSnake);\r\n\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}